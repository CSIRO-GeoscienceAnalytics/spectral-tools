<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>spex.io.instruments API documentation</title>
<meta name="description" content="Classes for reading in Spectral data from a variety of sources. Nameley, CSV files, TSG datasets, Image Data in the ENVI data format and Numpy arrays" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spex.io.instruments</code></h1>
</header>
<section id="section-intro">
<p>Classes for reading in Spectral data from a variety of sources. Nameley, CSV files, TSG datasets, Image Data in the ENVI data format and Numpy arrays</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Classes for reading in Spectral data from a variety of sources. Nameley, CSV files, TSG datasets, Image Data in the ENVI data format and Numpy arrays

&#34;&#34;&#34;
import os
from abc import ABC, abstractmethod
import numpy as np
import pandas as pd
import spectral.io.envi as envi
from spex.utilities.find_indices import find_indices


class Instrument(ABC):
    &#34;&#34;&#34;
    Abstract base class for the instrument class

    &#34;&#34;&#34;
    @abstractmethod
    def return_all_spectra(self):
        &#34;&#34;&#34;
        Get all of the spectra associated with the instrument

        Returns:
            all of the spectra, or at least a reference to it

        &#34;&#34;&#34;
        return

    @abstractmethod
    def datagenerator(self):
        &#34;&#34;&#34;
        A data generator used to return a single spectrum at a time from the dataset

        Returns:
            an iterator

        &#34;&#34;&#34;
        return

    @abstractmethod
    def get_ordinates(self):
        &#34;&#34;&#34;
        Get the ordinates of the associated instrument

        Returns:
            get the ordinates that go along with the spectral data

        &#34;&#34;&#34;
        return


class Tsg(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a TSG dataset

    Attributes:
        band_header_data (Dataframe): The contents of the additional data contained in a TSG file e.g. depths, scalars

        band_header_data_names (list): The column names of the data in the band_header_data

        bip_file (str): The path name of the TSG binary file

        data_directory (str): The directory where the binary file is located

        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        do_hull (bool): Use a convex hull if spectral extraction is performed

        features (numpy array): the spectral features for the dataset if they are calculated

        file_base_name (str): The file name without the path

        filename_bits (tuple): The filename split into the base name and extension

        inspection_indices (list): The indices that correspond to the wavelengths of the inspection_range

        inspection_range (list): The desired range to use for spectral feature extraction e.g. [2000, 2500]

        instrument_name (str): &#39;TSG&#39;

        is_this_TIR (bool): If _tir is found in the filename this flag is set to True otherwise False

        mask (list): False where the data is no good and True where it is good

        metadata (dict): The TSG files ENVI hdr information

        ordinates (ndarray): The ordinates associated with the spectral data

        return_hull (bool): to return the actual hull or not. Default is False

        spectra (ndarray): The TSG spectral data (samples x bands)

        spectral_mix (unknown): Hmm probably when I was mucking around with unmixing. TODO maybe delete this

        tsg_text_file (str): The pathname of the input *.tsg file

    &#34;&#34;&#34;

    def __init__(self, instrument_files):
        &#34;&#34;&#34;
        Create an instance of a Tsg class to either retrieve spectra and/or metadata associated with the TSG dataset

        Args:
            instrument_files (list): A list [path to TSG binary file, path to TSG .tsg file]

        Examples:
            from spex.io.instrument import Tsg

            input_files = [&#34;tsg_test.bip&#34;, &#34;tsg_test.tsg&#34;]

            Tsg_dataset = Tsg(input_files)

        &#34;&#34;&#34;
        self.instrument_name = &#39;TSG&#39;
        self.bip_file = instrument_files[0]
        self.tsg_text_file = instrument_files[1]
        #self.existing_header_file = None
        self.data_directory = os.path.dirname(self.bip_file)
        self.file_base_name = os.path.basename(self.bip_file)
        self.filename_bits = os.path.splitext(self.file_base_name)
        self.is_this_TIR = False
        #self.flip_data_along_yaxis = False
        self.ordinates = None
        #self.whats_not_masked = None
        self.return_hull = False
        #self.load_all = True
        self.band_header_data_names = None
        self.band_header_data = None
        self.mask = None
        self.dimensions = None
        self.features = None
        self.spectral_mix = None

        if &#39;.tsg&#39; in self.tsg_text_file:
            # read in the tsg file and create a header file
            header_file, header = self.read_tsg_file()
            tsg_data = self._open_with_generated_header(header, image=self.bip_file)

            self.ordinates = np.asarray(tsg_data.bands.centers)
            if self.band_header_data.filter(like=&#39;Final Mask&#39;).shape[1] &gt; 0:
                self.mask = list(self.band_header_data.filter(like=&#39;Final Mask&#39;).values[:, 0] &gt; 0)
            else:
                self.mask = list(np.ones(tsg_data.params.nrows, dtype=bool))

            self.spectra = tsg_data.spectra  # self.return_all_spectra()  # self.tsg_data.spectra
            self.dimensions = self.spectra.ndim
            self.dimension_shape = self.spectra.shape
            self.metadata = tsg_data.metadata
        else:
            print(&#39;Nope!, I need a bip file and a tsg file&#39;)

        self.do_hull = True
        self.is_this_TIR = False
        # see if it is a TIR file
        if &#39;_tir&#39; in self.bip_file:
            self.is_this_TIR = True
            self.do_hull = False

        self.inspection_range = None
        self.inspection_indices = None

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the TSG spectral data

        &#34;&#34;&#34;
        return self.ordinates

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the TSG dataset

        Yields:
            A spectrum from the dataset

        &#34;&#34;&#34;
        for spectrum in self.spectra: #tsg_data.spectra:
            yield spectrum

    def read_tsg_file(self):
        # open the tsg file and get the text information
        &#34;&#34;&#34;
        A reader for the *.tsg file

        Returns:
            tsg filename, a dict of the metadata items needed to construct an ENVI header file

        &#34;&#34;&#34;

        with open(self.tsg_text_file, mode=&#39;r&#39;) as f:
            tsg_file_data = f.readlines()

            # get the indices and names of all the items within [] tags
            where_are_the_headers = [(index, x.split(&#34;\n&#34;)[0]) for index, x in enumerate(tsg_file_data) if &#39;[&#39; in x]

            # a dictionary for storing additional parameters needed in the *.hdr file
            d = {&#39;description&#39;: &#39;Extracted info from the .tsg file to make this ENVI header file.&#39;,
                 &#39;lines&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastsample =&#39; in s][0],
                 &#39;samples&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastband =&#39; in s][0], &#39;bands&#39;: &#39;1&#39;,
                 &#39;header offset&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;dataheader =&#39; in s][0], &#39;data type&#39;: &#39;4&#39;,
                 &#39;interleave&#39;: &#39;bsq&#39;, &#39;byte order&#39;: &#39;0&#39;}
            # In an ENVI spectral library the lines are the number of samples and the samples are the number of bands

            # get the sample names. This is often massive
            index = [index for index, s in enumerate(tsg_file_data) if &#39;[sample headers]&#39; in s][0] + 1
            spectra_names = []
            for i in range(int(d.get(&#39;lines&#39;))):
                spectra_names.append(tsg_file_data[index + i].split(&#39;:&#39;)[1])
            d[&#39;spectra names&#39;] = spectra_names

            index = [index for index, s in enumerate(tsg_file_data) if &#39;[wavelength specs]&#39; in s][0] + 1
            wave_specs = tsg_file_data[index].split()[0:2]
            delta_waves = round((float(wave_specs[1]) - float(wave_specs[0])) / float(d[&#39;samples&#39;]))
            wavelengths = []
            for i in range(int(d[&#39;samples&#39;])):
                wavelengths.append(float(wave_specs[0]) + i * delta_waves)
            d[&#39;wavelength&#39;] = wavelengths

            # lets get all of the other information stuffed into the binary file for each sample
            band_hdr = [(index, x[0]) for index, x in enumerate(where_are_the_headers) if &#39;[band headers]&#39; in x[1]][0]
            band_hdr_start = band_hdr[1] + 1
            band_hdr_stop = where_are_the_headers[band_hdr[0] + 1][0] - 1
            band_header_indices = [np.long(x.split(&#34;:&#34;)[0]) for x in tsg_file_data[band_hdr_start:band_hdr_stop]]
            band_header_fields = [x.split(&#34;:&#34;)[1].split(&#34;;&#34;)[0].split(&#34;\n&#34;)[0] for x in
                                  tsg_file_data[band_hdr_start:band_hdr_stop]]

            # open a memmap that is past the spectral data.
            # We are going to grab all the other data associated with each spectrum
            offset = int(d[&#39;lines&#39;]) * int(d[&#39;samples&#39;]) * np.dtype(&#39;float32&#39;).itemsize
            file_memmap = np.memmap(self.bip_file, dtype=&#39;float32&#39;, mode=&#39;r&#39;, offset=offset,
                                    shape=(int(d[&#39;lines&#39;]), int(d[&#39;samples&#39;])))

            # lets create a pandas dataset of the header data and store it
            header_data = np.asarray(file_memmap[:, band_header_indices])
            tsg_df = pd.DataFrame(header_data, columns=band_header_fields)
            self.band_header_data_names = band_header_fields
            self.band_header_data = tsg_df

            base_filename = os.path.splitext(self.bip_file)[0]
            out_filename = base_filename + &#39;.hdr&#39;
            if os.access(os.path.dirname(out_filename), os.W_OK):
                envi.write_envi_header(out_filename, d, is_library=True)
                d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
            else:
                d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
                out_filename = None

        return out_filename, d

    def make_header_dict(self, tsg_file_data):
        # open the tsg file and get the text information
        &#34;&#34;&#34;
        Gathers up the required metadata needed to create an internal representation of an ENVI header file that in turn
        allows us to read the TSG *.bip file via spectral pythons routines

        Args:
            tsg_file_data (list): A list containing the various metadata contained in a *.tsg file

        Returns:
            dict: A dict of the various metadata items in a format compatible with an ENVI header

        &#34;&#34;&#34;

        # a dictionary for storing additional parameters needed in the *.hdr file
        d = {&#39;description&#39;: &#39;extracted header file from TSG&#39;,
             &#39;lines&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastsample =&#39; in s][0],
             &#39;samples&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastband =&#39; in s][0], &#39;bands&#39;: &#39;1&#39;,
             &#39;header offset&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;dataheader =&#39; in s][0], &#39;data type&#39;: &#39;4&#39;,
             &#39;interleave&#39;: &#39;bsq&#39;, &#39;byte order&#39;: &#39;0&#39;}
        # extract the metadata we need for the *.hdr file
        # in a envi spectral library the lines are the number of samples and the samples are the number of bands

        # get the sample names. This is often massive
        index = [index for index, s in enumerate(tsg_file_data) if &#39;sample headers&#39; in s][0] + 1
        spectra_names = []
        for i in range(int(d.get(&#39;lines&#39;))):
            spectra_names.append(tsg_file_data[index + i].split(&#39;:&#39;)[1])
        d[&#39;spectra names&#39;] = spectra_names

        index = [index for index, s in enumerate(tsg_file_data) if &#39;[wavelength specs]&#39; in s][0] + 1
        wave_specs = tsg_file_data[index].split()[0:2]
        delta_waves = round((float(wave_specs[1]) - float(wave_specs[0])) / float(d[&#39;samples&#39;]))
        wvls = []
        for i in range(int(d[&#39;samples&#39;])):
            wvls.append(float(wave_specs[0]) + i * delta_waves)
        d[&#39;wavelength&#39;] = wvls

        # open a memmap
        offset = int(d[&#39;lines&#39;]) * int(d[&#39;samples&#39;]) * np.dtype(&#39;float32&#39;).itemsize
        file_memmap = np.memmap(self.bip_file, dtype=&#39;float32&#39;, mode=&#39;r&#39;, offset=offset,
                                shape=(int(d[&#39;lines&#39;]), int(d[&#39;samples&#39;])))

        depth_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Depth (m);&#39; in s]
        if depth_index:
            d[&#39;depths&#39;] = np.asarray(file_memmap[:, depth_index[0]])
        else:
            d[&#39;depths&#39;] = range(int(d[&#39;lines&#39;]))

        final_mask_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Final Mask;&#39; in s]
        if final_mask_index:
            d[&#39;mask&#39;] = np.asarray(file_memmap[:, final_mask_index[0]])
        else:
            kahuna_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Kahuna;&#39; in s]
            if kahuna_index:
                d[&#39;mask&#39;] = np.asarray(file_memmap[:, kahuna_index[0]])
            else:
                d[&#39;mask&#39;] = np.full(int(d[&#39;lines&#39;]), 1)

        prof_min_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:prof_min;&#39; in s]
        if prof_min_index:
            d[&#39;prof_min&#39;] = np.asarray(file_memmap[:, prof_min_index[0]])

        d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
        return d

    @staticmethod
    def _open_with_generated_header(header_dictionary, image=None):
        &#34;&#34;&#34;
        Opens an image or spectral library with an associated ENVI HDR header file

        Args:
            header_dictionary (dict): a dict of the TSG data file metadata
            image (str): Optional name of the associated image data file.

        Returns:
            (object): class:`spectral.SpyFile` or :class:`spectral.io.envi.SpectralLibrary`

        Raises:

            TypeError, EnviDataFileNotFoundError

        If the specified file is not found in the current directory, all
        directories listed in the SPECTRAL_DATA environment variable will be
        searched until the file is found.  Based on the name of the header file,
        this function will search for the image file in the same directory as the
        header, looking for a file with the same name as the header but different
        extension. Extensions recognized are .img, .dat, .sli, and no extension.
        Capitalized versions of the file extensions are also searched.

        &#34;&#34;&#34;
        envi.check_compatibility(header_dictionary)
        envi_information = envi.gen_params(header_dictionary)
        envi_information.filename = image

        if header_dictionary.get(&#39;file type&#39;) == &#39;ENVI Spectral Library&#39;:
            # File is a spectral library
            data = np.fromfile(envi_information.filename, envi_information.dtype,
                               envi_information.ncols * envi_information.nrows)
            data.shape = (envi_information.nrows, envi_information.ncols)
            return envi.SpectralLibrary(data, header_dictionary, envi_information)

        #  Create the appropriate object type for the interleave format.
        inter = header_dictionary[&#34;interleave&#34;]
        if inter == &#39;bil&#39; or inter == &#39;BIL&#39;:
            from spectral.io.bilfile import BilFile
            img = BilFile(envi_information, header_dictionary)
        elif inter == &#39;bip&#39; or inter == &#39;BIP&#39;:
            from spectral.io.bipfile import BipFile
            img = BipFile(envi_information, header_dictionary)
        else:
            from spectral.io.bsqfile import BsqFile
            img = BsqFile(envi_information, header_dictionary)

        img.scale_factor = float(header_dictionary.get(&#39;reflectance scale factor&#39;, 1.0))

        # Add band info

        if &#39;wavelength&#39; in header_dictionary:
            try:
                img.bands.centers = [float(b) for b in header_dictionary[&#39;wavelength&#39;]]
            except:
                pass
        if &#39;fwhm&#39; in header_dictionary:
            try:
                img.bands.bandwidths = [float(f) for f in header_dictionary[&#39;fwhm&#39;]]
            except:
                pass
        img.bands.band_unit = header_dictionary.get(&#39;wavelength units&#39;, None)

        if &#39;bbl&#39; in header_dictionary:
            try:
                header_dictionary[&#39;bbl&#39;] = [int(b) for b in header_dictionary[&#39;bbl&#39;]]
            except:
                print(&#39;Unable to parse bad band list (bbl) in header as integers.&#39;)
        return img

    def return_band_header_data(self):
        &#34;&#34;&#34;
        returns all of the band header data if it exists.

        In a TSG file this would be things like the depth, scalars, etc

        &#34;&#34;&#34;
        return self.band_header_data

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;
        spectrum = self.spectra
        return spectrum

    def return_single_spectrum(self, sample_number):
        &#34;&#34;&#34;
        returns the spectrum at sample location sample_number

        Args:
            sample_number (int): Index location in the spectral array that you want the sample from

        Returns:
            A numpy array with the spectrum found at sample_number

        &#34;&#34;&#34;
        spectrum = self.spectra[sample_number, :]
        return spectrum


class ImageData(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a spectral image file

    Attributes:
        bin_file (str): The path name of the image binary file

        data_directory (str): The directory where the binary file is located

        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        file_base_name (str): The file name without the path

        filename_bits (tuple): The filename split into the base name and extension

        header_file (str): The pathname of the accompanying header *.hdr file

        metadata (dict): The ENVI hdr information

        name (str): The class name

        ordinates (ndarray): The ordinates associated with the spectral data

        return_hull (bool): to return the actual hull or not. Default is False

        spectra (ndarray): The spectral data (samples x bands)

    &#34;&#34;&#34;

    def __init__(self, instrument_files):
        &#34;&#34;&#34;
        Create an instance of an ImageData class to either retrieve spectra and/or metadata associated with an image
        dataset that is in an ENVI file format.

        Args:
            instrument_files (list): A list [path to image binary file, path to image *.hdr file]

        Examples:
            from spex.io.instrument import ImageData

            input_files = [&#34;image.bip&#34;, &#34;image.hdr&#34;]

            image_dataset = ImageData(input_files)

        &#34;&#34;&#34;

        self.name = &#39;ImageData&#39;
        self.bin_file = instrument_files[0]
        self.header_file = instrument_files[1]
        self.data_directory = os.path.dirname(self.bin_file)
        self.file_base_name = os.path.basename(self.bin_file)
        self.filename_bits = os.path.splitext(self.file_base_name)
        self.ordinates = None
        self.dimensions = None
        self.return_hull = False
        #self.load_all = True

        self.spectra = envi.open(instrument_files[1], image=instrument_files[0])
        self.ordinates = self.get_ordinates()
        self.dimensions = self.spectra.shape.__len__()
        self.dimension_shape = self.spectra.shape
        self.metadata = self.spectra.metadata

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the spectral data
        e.g. the wavelengths, or wavenumbers or indices or whatever it is that is used for ordinates

        &#34;&#34;&#34;

        return np.asarray(self.spectra.bands.centers)

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the dataset

        Yields:
            a spectrum from the dataset

        &#34;&#34;&#34;

        for spectra in self.spectra[:, :, :]:
            for spec in spectra:
                yield spec

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;

        return self.spectra[:, :, :]

    def return_single_spectrum(self, coordinates):
        &#34;&#34;&#34;
        returns the spectrum at the coordinates

        Args:
            coordinates (list): A list containing the row and column where the sample is located

        Returns:
            The spectrum at the coordinates

        &#34;&#34;&#34;

        if len(coordinates) &lt; 2:
            coordinates = [coordinates[0], 0]

        row = coordinates[0]
        col = coordinates[1]
        spectrum = np.squeeze(self.spectra[row, col, :])
        return spectrum


class CsvSpectra(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a CSV file to access the spectra as a numpy array. Its really only a
    convenience thing and uses pandas to get the data.

    Attributes:
        csv_file (str): The path name of the csv file

        data_directory (str): The directory where the binary file is located

        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        file_base_name (str): The file name without the path

        filename_bits (tuple): The filename split into the base name and extension

        instrument_name (str): &#39;CSV&#39; The classname

        metadata (dict): The csv file information

        names (ndarray): The ssamples names of the spectra

        ordinates (ndarray): The ordinates associated with the spectral data

        spectra (ndarray): The spectral data (samples x bands)

    &#34;&#34;&#34;

    def __init__(self, instrument_file, order=0, nrows=None):
        # todo needs a switch for csv files that have the first column as the wavelength and the first row as the names
        &#34;&#34;&#34;
        Class initialisation

        Args:
            instrument_file (list): The pathname of a CSV file

            order (int): The order of the CSV file.
                order = 0 is wavelength in the first row, names in the first column
                order = 1 is the wavelengths in the first column and names in the first row

            nrows (int): Default is None, how many rows to read in

        Notes:
            required format of the CSV is the first row is wavelength/index, and the first column (the index) contains
            sample names

        &#34;&#34;&#34;
        self.instrument_name = &#39;CSV&#39;
        self.csv_file = instrument_file[0]
        self.data_directory = os.path.dirname(self.csv_file)
        self.file_base_name = os.path.basename(self.csv_file)
        self.filename_bits = os.path.splitext(self.file_base_name)
        if order == 0:
            df_csv_spectra = pd.read_csv(self.csv_file, index_col=0, nrows=nrows)
            self.names = df_csv_spectra.index.values
            self.spectra = df_csv_spectra.values
            self.ordinates = df_csv_spectra.columns.values.astype(float)
        else:
            df_csv_spectra = pd.read_csv(self.csv_file, nrows=nrows)
            self.names = df_csv_spectra.columns.values[1:]
            self.spectra = np.transpose(df_csv_spectra.values[:, 1:])
            self.ordinates = df_csv_spectra.iloc[:, 0].values.astype(float)

        self.dimensions = self.spectra.ndim
        self.dimension_shape = self.spectra.shape
        self.metadata = {&#39;Type&#39;: &#39;CSV&#39;,
                         &#39;Dimensions&#39;: self.dimensions}

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the dataset

        Yields:
            a single spectrum from the dataset

        &#34;&#34;&#34;
        for spectrum in self.spectra:
            yield spectrum

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the spectral data

        &#34;&#34;&#34;
        return self.ordinates

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;
        return self.spectra

    def return_single_spectrum(self, sample_number):
        &#34;&#34;&#34;
        returns the spectrum at sample location sample_number

        Args:
            sample_number (int): The sample index of the sample you want

        Returns:
            The spectrum found at sample_number

        &#34;&#34;&#34;
        spectrum = self.spectra[sample_number, :]
        return spectrum


class NumpySpectra(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a Numpy array of spectral data

    Attributes:
        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        metadata (dict): The data information

        ordinates (ndarray): The ordinates associated with the spectral data

        spectra (ndarray): The spectral data (samples x bands)


    &#34;&#34;&#34;

    def __init__(self, instrument_files):
        &#34;&#34;&#34;
        Instantiate instrument class object for an Input of numpy spectra

        Args:
            instrument_files (list): 2 numpy arrays consisting of the ordinates and the spectral data.
                e.g. [ordinates, spectra]

            This can be of the following form, (B), (NxB) or (NxMxB) where B is the number of bands, N is the number of
            samples and M is the number rows/cols. Seriously it doesnt matter as long as the bands are the last dimension.

            ordinates (numpy): A numpy array of size (B)

        &#34;&#34;&#34;
        # TODO check that the numbers of ordinates is the same as the last dimension of the spectra
        self._name = &#39;NumpySpectra&#39;
        # get all of the info out
        self.ordinates = instrument_files[0]
        self.spectra = instrument_files[1]
        self.dimensions = self.spectra.ndim
        self.dimension_shape = self.spectra.shape
        self.metadata = {&#39;Type&#39;: &#39;Numpy&#39;,
                         &#39;Dimensions&#39;: self.dimensions}

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the dataset

        Yields:
            a spectrum from the dataset

        &#34;&#34;&#34;
        ndims = self.spectra.ndim
        if ndims == 1:
            yield self.spectra
        elif ndims == 2:
            for spectrum in self.spectra:
                yield spectrum
        elif ndims == 3:
            for spectra in self.spectra:
                for spec in spectra:
                    yield spec

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the spectral data

        &#34;&#34;&#34;

        return self.ordinates

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;

        return self.spectra

    def return_single_spectrum(self, sample_number):
        &#34;&#34;&#34;
        returns the spectrum at sample location sample_number

        Args:
            sample_number (int): location in the spectral array that you want the sample from

        Returns:
            The spectrum found at sample_number

        &#34;&#34;&#34;

        spectrum = self.spectra[sample_number, :]
        return spectrum</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spex.io.instruments.CsvSpectra"><code class="flex name class">
<span>class <span class="ident">CsvSpectra</span></span>
<span>(</span><span>instrument_file, order=0, nrows=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the Instrument class for a CSV file to access the spectra as a numpy array. Its really only a
convenience thing and uses pandas to get the data.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>csv_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The path name of the csv file</dd>
<dt><strong><code>data_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory where the binary file is located</dd>
<dt><strong><code>dimension_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the spectral data</dd>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>int</code></dt>
<dd>How many dimensions there are</dd>
<dt><strong><code>file_base_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The file name without the path</dd>
<dt><strong><code>filename_bits</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The filename split into the base name and extension</dd>
<dt><strong><code>instrument_name</code></strong> :&ensp;<code>str</code></dt>
<dd>'CSV' The classname</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>The csv file information</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The ssamples names of the spectra</dd>
<dt><strong><code>ordinates</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The ordinates associated with the spectral data</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The spectral data (samples x bands)</dd>
</dl>
<p>Class initialisation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instrument_file</code></strong> :&ensp;<code>list</code></dt>
<dd>The pathname of a CSV file</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the CSV file.
order = 0 is wavelength in the first row, names in the first column
order = 1 is the wavelengths in the first column and names in the first row</dd>
<dt><strong><code>nrows</code></strong> :&ensp;<code>int</code></dt>
<dd>Default is None, how many rows to read in</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>required format of the CSV is the first row is wavelength/index, and the first column (the index) contains
sample names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CsvSpectra(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a CSV file to access the spectra as a numpy array. Its really only a
    convenience thing and uses pandas to get the data.

    Attributes:
        csv_file (str): The path name of the csv file

        data_directory (str): The directory where the binary file is located

        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        file_base_name (str): The file name without the path

        filename_bits (tuple): The filename split into the base name and extension

        instrument_name (str): &#39;CSV&#39; The classname

        metadata (dict): The csv file information

        names (ndarray): The ssamples names of the spectra

        ordinates (ndarray): The ordinates associated with the spectral data

        spectra (ndarray): The spectral data (samples x bands)

    &#34;&#34;&#34;

    def __init__(self, instrument_file, order=0, nrows=None):
        # todo needs a switch for csv files that have the first column as the wavelength and the first row as the names
        &#34;&#34;&#34;
        Class initialisation

        Args:
            instrument_file (list): The pathname of a CSV file

            order (int): The order of the CSV file.
                order = 0 is wavelength in the first row, names in the first column
                order = 1 is the wavelengths in the first column and names in the first row

            nrows (int): Default is None, how many rows to read in

        Notes:
            required format of the CSV is the first row is wavelength/index, and the first column (the index) contains
            sample names

        &#34;&#34;&#34;
        self.instrument_name = &#39;CSV&#39;
        self.csv_file = instrument_file[0]
        self.data_directory = os.path.dirname(self.csv_file)
        self.file_base_name = os.path.basename(self.csv_file)
        self.filename_bits = os.path.splitext(self.file_base_name)
        if order == 0:
            df_csv_spectra = pd.read_csv(self.csv_file, index_col=0, nrows=nrows)
            self.names = df_csv_spectra.index.values
            self.spectra = df_csv_spectra.values
            self.ordinates = df_csv_spectra.columns.values.astype(float)
        else:
            df_csv_spectra = pd.read_csv(self.csv_file, nrows=nrows)
            self.names = df_csv_spectra.columns.values[1:]
            self.spectra = np.transpose(df_csv_spectra.values[:, 1:])
            self.ordinates = df_csv_spectra.iloc[:, 0].values.astype(float)

        self.dimensions = self.spectra.ndim
        self.dimension_shape = self.spectra.shape
        self.metadata = {&#39;Type&#39;: &#39;CSV&#39;,
                         &#39;Dimensions&#39;: self.dimensions}

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the dataset

        Yields:
            a single spectrum from the dataset

        &#34;&#34;&#34;
        for spectrum in self.spectra:
            yield spectrum

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the spectral data

        &#34;&#34;&#34;
        return self.ordinates

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;
        return self.spectra

    def return_single_spectrum(self, sample_number):
        &#34;&#34;&#34;
        returns the spectrum at sample location sample_number

        Args:
            sample_number (int): The sample index of the sample you want

        Returns:
            The spectrum found at sample_number

        &#34;&#34;&#34;
        spectrum = self.spectra[sample_number, :]
        return spectrum</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spex.io.instruments.Instrument" href="#spex.io.instruments.Instrument">Instrument</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spex.io.instruments.CsvSpectra.datagenerator"><code class="name flex">
<span>def <span class="ident">datagenerator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>an iterator to return a single spectrum at a time from the dataset</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>a single spectrum from the dataset</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datagenerator(self):
    &#34;&#34;&#34;
    an iterator to return a single spectrum at a time from the dataset

    Yields:
        a single spectrum from the dataset

    &#34;&#34;&#34;
    for spectrum in self.spectra:
        yield spectrum</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.CsvSpectra.get_ordinates"><code class="name flex">
<span>def <span class="ident">get_ordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the ordinates associated with the spectral data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ordinates(self):
    &#34;&#34;&#34;
    returns the ordinates associated with the spectral data

    &#34;&#34;&#34;
    return self.ordinates</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.CsvSpectra.return_all_spectra"><code class="name flex">
<span>def <span class="ident">return_all_spectra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all of the spectra as a numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_all_spectra(self):
    &#34;&#34;&#34;
    return all of the spectra as a numpy array

    &#34;&#34;&#34;
    return self.spectra</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.CsvSpectra.return_single_spectrum"><code class="name flex">
<span>def <span class="ident">return_single_spectrum</span></span>(<span>self, sample_number)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the spectrum at sample location sample_number</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample_number</code></strong> :&ensp;<code>int</code></dt>
<dd>The sample index of the sample you want</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The spectrum found at sample_number</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_single_spectrum(self, sample_number):
    &#34;&#34;&#34;
    returns the spectrum at sample location sample_number

    Args:
        sample_number (int): The sample index of the sample you want

    Returns:
        The spectrum found at sample_number

    &#34;&#34;&#34;
    spectrum = self.spectra[sample_number, :]
    return spectrum</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spex.io.instruments.ImageData"><code class="flex name class">
<span>class <span class="ident">ImageData</span></span>
<span>(</span><span>instrument_files)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the Instrument class for a spectral image file</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>bin_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The path name of the image binary file</dd>
<dt><strong><code>data_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory where the binary file is located</dd>
<dt><strong><code>dimension_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the spectral data</dd>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>int</code></dt>
<dd>How many dimensions there are</dd>
<dt><strong><code>file_base_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The file name without the path</dd>
<dt><strong><code>filename_bits</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The filename split into the base name and extension</dd>
<dt><strong><code>header_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The pathname of the accompanying header *.hdr file</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>The ENVI hdr information</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The class name</dd>
<dt><strong><code>ordinates</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The ordinates associated with the spectral data</dd>
<dt><strong><code>return_hull</code></strong> :&ensp;<code>bool</code></dt>
<dd>to return the actual hull or not. Default is False</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The spectral data (samples x bands)</dd>
</dl>
<p>Create an instance of an ImageData class to either retrieve spectra and/or metadata associated with an image
dataset that is in an ENVI file format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instrument_files</code></strong> :&ensp;<code>list</code></dt>
<dd>A list [path to image binary file, path to image *.hdr file]</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>from spex.io.instrument import ImageData</p>
<p>input_files = ["image.bip", "image.hdr"]</p>
<p>image_dataset = ImageData(input_files)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageData(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a spectral image file

    Attributes:
        bin_file (str): The path name of the image binary file

        data_directory (str): The directory where the binary file is located

        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        file_base_name (str): The file name without the path

        filename_bits (tuple): The filename split into the base name and extension

        header_file (str): The pathname of the accompanying header *.hdr file

        metadata (dict): The ENVI hdr information

        name (str): The class name

        ordinates (ndarray): The ordinates associated with the spectral data

        return_hull (bool): to return the actual hull or not. Default is False

        spectra (ndarray): The spectral data (samples x bands)

    &#34;&#34;&#34;

    def __init__(self, instrument_files):
        &#34;&#34;&#34;
        Create an instance of an ImageData class to either retrieve spectra and/or metadata associated with an image
        dataset that is in an ENVI file format.

        Args:
            instrument_files (list): A list [path to image binary file, path to image *.hdr file]

        Examples:
            from spex.io.instrument import ImageData

            input_files = [&#34;image.bip&#34;, &#34;image.hdr&#34;]

            image_dataset = ImageData(input_files)

        &#34;&#34;&#34;

        self.name = &#39;ImageData&#39;
        self.bin_file = instrument_files[0]
        self.header_file = instrument_files[1]
        self.data_directory = os.path.dirname(self.bin_file)
        self.file_base_name = os.path.basename(self.bin_file)
        self.filename_bits = os.path.splitext(self.file_base_name)
        self.ordinates = None
        self.dimensions = None
        self.return_hull = False
        #self.load_all = True

        self.spectra = envi.open(instrument_files[1], image=instrument_files[0])
        self.ordinates = self.get_ordinates()
        self.dimensions = self.spectra.shape.__len__()
        self.dimension_shape = self.spectra.shape
        self.metadata = self.spectra.metadata

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the spectral data
        e.g. the wavelengths, or wavenumbers or indices or whatever it is that is used for ordinates

        &#34;&#34;&#34;

        return np.asarray(self.spectra.bands.centers)

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the dataset

        Yields:
            a spectrum from the dataset

        &#34;&#34;&#34;

        for spectra in self.spectra[:, :, :]:
            for spec in spectra:
                yield spec

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;

        return self.spectra[:, :, :]

    def return_single_spectrum(self, coordinates):
        &#34;&#34;&#34;
        returns the spectrum at the coordinates

        Args:
            coordinates (list): A list containing the row and column where the sample is located

        Returns:
            The spectrum at the coordinates

        &#34;&#34;&#34;

        if len(coordinates) &lt; 2:
            coordinates = [coordinates[0], 0]

        row = coordinates[0]
        col = coordinates[1]
        spectrum = np.squeeze(self.spectra[row, col, :])
        return spectrum</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spex.io.instruments.Instrument" href="#spex.io.instruments.Instrument">Instrument</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spex.io.instruments.ImageData.datagenerator"><code class="name flex">
<span>def <span class="ident">datagenerator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>an iterator to return a single spectrum at a time from the dataset</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>a spectrum from the dataset</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datagenerator(self):
    &#34;&#34;&#34;
    an iterator to return a single spectrum at a time from the dataset

    Yields:
        a spectrum from the dataset

    &#34;&#34;&#34;

    for spectra in self.spectra[:, :, :]:
        for spec in spectra:
            yield spec</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.ImageData.get_ordinates"><code class="name flex">
<span>def <span class="ident">get_ordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the ordinates associated with the spectral data
e.g. the wavelengths, or wavenumbers or indices or whatever it is that is used for ordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ordinates(self):
    &#34;&#34;&#34;
    returns the ordinates associated with the spectral data
    e.g. the wavelengths, or wavenumbers or indices or whatever it is that is used for ordinates

    &#34;&#34;&#34;

    return np.asarray(self.spectra.bands.centers)</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.ImageData.return_all_spectra"><code class="name flex">
<span>def <span class="ident">return_all_spectra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all of the spectra as a numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_all_spectra(self):
    &#34;&#34;&#34;
    return all of the spectra as a numpy array

    &#34;&#34;&#34;

    return self.spectra[:, :, :]</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.ImageData.return_single_spectrum"><code class="name flex">
<span>def <span class="ident">return_single_spectrum</span></span>(<span>self, coordinates)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the spectrum at the coordinates</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code></dt>
<dd>A list containing the row and column where the sample is located</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The spectrum at the coordinates</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_single_spectrum(self, coordinates):
    &#34;&#34;&#34;
    returns the spectrum at the coordinates

    Args:
        coordinates (list): A list containing the row and column where the sample is located

    Returns:
        The spectrum at the coordinates

    &#34;&#34;&#34;

    if len(coordinates) &lt; 2:
        coordinates = [coordinates[0], 0]

    row = coordinates[0]
    col = coordinates[1]
    spectrum = np.squeeze(self.spectra[row, col, :])
    return spectrum</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spex.io.instruments.Instrument"><code class="flex name class">
<span>class <span class="ident">Instrument</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for the instrument class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Instrument(ABC):
    &#34;&#34;&#34;
    Abstract base class for the instrument class

    &#34;&#34;&#34;
    @abstractmethod
    def return_all_spectra(self):
        &#34;&#34;&#34;
        Get all of the spectra associated with the instrument

        Returns:
            all of the spectra, or at least a reference to it

        &#34;&#34;&#34;
        return

    @abstractmethod
    def datagenerator(self):
        &#34;&#34;&#34;
        A data generator used to return a single spectrum at a time from the dataset

        Returns:
            an iterator

        &#34;&#34;&#34;
        return

    @abstractmethod
    def get_ordinates(self):
        &#34;&#34;&#34;
        Get the ordinates of the associated instrument

        Returns:
            get the ordinates that go along with the spectral data

        &#34;&#34;&#34;
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spex.io.instruments.CsvSpectra" href="#spex.io.instruments.CsvSpectra">CsvSpectra</a></li>
<li><a title="spex.io.instruments.ImageData" href="#spex.io.instruments.ImageData">ImageData</a></li>
<li><a title="spex.io.instruments.NumpySpectra" href="#spex.io.instruments.NumpySpectra">NumpySpectra</a></li>
<li><a title="spex.io.instruments.Tsg" href="#spex.io.instruments.Tsg">Tsg</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spex.io.instruments.Instrument.datagenerator"><code class="name flex">
<span>def <span class="ident">datagenerator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A data generator used to return a single spectrum at a time from the dataset</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>an iterator</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def datagenerator(self):
    &#34;&#34;&#34;
    A data generator used to return a single spectrum at a time from the dataset

    Returns:
        an iterator

    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Instrument.get_ordinates"><code class="name flex">
<span>def <span class="ident">get_ordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the ordinates of the associated instrument</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>get the ordinates that go along with the spectral data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_ordinates(self):
    &#34;&#34;&#34;
    Get the ordinates of the associated instrument

    Returns:
        get the ordinates that go along with the spectral data

    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Instrument.return_all_spectra"><code class="name flex">
<span>def <span class="ident">return_all_spectra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of the spectra associated with the instrument</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>all</code> of <code>the spectra,</code> or <code>at least a reference to it</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def return_all_spectra(self):
    &#34;&#34;&#34;
    Get all of the spectra associated with the instrument

    Returns:
        all of the spectra, or at least a reference to it

    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spex.io.instruments.NumpySpectra"><code class="flex name class">
<span>class <span class="ident">NumpySpectra</span></span>
<span>(</span><span>instrument_files)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the Instrument class for a Numpy array of spectral data</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>dimension_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the spectral data</dd>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>int</code></dt>
<dd>How many dimensions there are</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>The data information</dd>
<dt><strong><code>ordinates</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The ordinates associated with the spectral data</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The spectral data (samples x bands)</dd>
</dl>
<p>Instantiate instrument class object for an Input of numpy spectra</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instrument_files</code></strong> :&ensp;<code>list</code></dt>
<dd>2 numpy arrays consisting of the ordinates and the spectral data.
e.g. [ordinates, spectra]</dd>
</dl>
<p>This can be of the following form, (B), (NxB) or (NxMxB) where B is the number of bands, N is the number of
samples and M is the number rows/cols. Seriously it doesn't matter as long as the bands are the last dimension.</p>
<dl>
<dt><strong><code>ordinates</code></strong> :&ensp;<code>numpy</code></dt>
<dd>A numpy array of size (B)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumpySpectra(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a Numpy array of spectral data

    Attributes:
        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        metadata (dict): The data information

        ordinates (ndarray): The ordinates associated with the spectral data

        spectra (ndarray): The spectral data (samples x bands)


    &#34;&#34;&#34;

    def __init__(self, instrument_files):
        &#34;&#34;&#34;
        Instantiate instrument class object for an Input of numpy spectra

        Args:
            instrument_files (list): 2 numpy arrays consisting of the ordinates and the spectral data.
                e.g. [ordinates, spectra]

            This can be of the following form, (B), (NxB) or (NxMxB) where B is the number of bands, N is the number of
            samples and M is the number rows/cols. Seriously it doesnt matter as long as the bands are the last dimension.

            ordinates (numpy): A numpy array of size (B)

        &#34;&#34;&#34;
        # TODO check that the numbers of ordinates is the same as the last dimension of the spectra
        self._name = &#39;NumpySpectra&#39;
        # get all of the info out
        self.ordinates = instrument_files[0]
        self.spectra = instrument_files[1]
        self.dimensions = self.spectra.ndim
        self.dimension_shape = self.spectra.shape
        self.metadata = {&#39;Type&#39;: &#39;Numpy&#39;,
                         &#39;Dimensions&#39;: self.dimensions}

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the dataset

        Yields:
            a spectrum from the dataset

        &#34;&#34;&#34;
        ndims = self.spectra.ndim
        if ndims == 1:
            yield self.spectra
        elif ndims == 2:
            for spectrum in self.spectra:
                yield spectrum
        elif ndims == 3:
            for spectra in self.spectra:
                for spec in spectra:
                    yield spec

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the spectral data

        &#34;&#34;&#34;

        return self.ordinates

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;

        return self.spectra

    def return_single_spectrum(self, sample_number):
        &#34;&#34;&#34;
        returns the spectrum at sample location sample_number

        Args:
            sample_number (int): location in the spectral array that you want the sample from

        Returns:
            The spectrum found at sample_number

        &#34;&#34;&#34;

        spectrum = self.spectra[sample_number, :]
        return spectrum</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spex.io.instruments.Instrument" href="#spex.io.instruments.Instrument">Instrument</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spex.io.instruments.NumpySpectra.datagenerator"><code class="name flex">
<span>def <span class="ident">datagenerator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>an iterator to return a single spectrum at a time from the dataset</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>a spectrum from the dataset</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datagenerator(self):
    &#34;&#34;&#34;
    an iterator to return a single spectrum at a time from the dataset

    Yields:
        a spectrum from the dataset

    &#34;&#34;&#34;
    ndims = self.spectra.ndim
    if ndims == 1:
        yield self.spectra
    elif ndims == 2:
        for spectrum in self.spectra:
            yield spectrum
    elif ndims == 3:
        for spectra in self.spectra:
            for spec in spectra:
                yield spec</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.NumpySpectra.get_ordinates"><code class="name flex">
<span>def <span class="ident">get_ordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the ordinates associated with the spectral data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ordinates(self):
    &#34;&#34;&#34;
    returns the ordinates associated with the spectral data

    &#34;&#34;&#34;

    return self.ordinates</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.NumpySpectra.return_all_spectra"><code class="name flex">
<span>def <span class="ident">return_all_spectra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all of the spectra as a numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_all_spectra(self):
    &#34;&#34;&#34;
    return all of the spectra as a numpy array

    &#34;&#34;&#34;

    return self.spectra</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.NumpySpectra.return_single_spectrum"><code class="name flex">
<span>def <span class="ident">return_single_spectrum</span></span>(<span>self, sample_number)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the spectrum at sample location sample_number</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample_number</code></strong> :&ensp;<code>int</code></dt>
<dd>location in the spectral array that you want the sample from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The spectrum found at sample_number</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_single_spectrum(self, sample_number):
    &#34;&#34;&#34;
    returns the spectrum at sample location sample_number

    Args:
        sample_number (int): location in the spectral array that you want the sample from

    Returns:
        The spectrum found at sample_number

    &#34;&#34;&#34;

    spectrum = self.spectra[sample_number, :]
    return spectrum</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spex.io.instruments.Tsg"><code class="flex name class">
<span>class <span class="ident">Tsg</span></span>
<span>(</span><span>instrument_files)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the Instrument class for a TSG dataset</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>band_header_data</code></strong> :&ensp;<code>Dataframe</code></dt>
<dd>The contents of the additional data contained in a TSG file e.g. depths, scalars</dd>
<dt><strong><code>band_header_data_names</code></strong> :&ensp;<code>list</code></dt>
<dd>The column names of the data in the band_header_data</dd>
<dt><strong><code>bip_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The path name of the TSG binary file</dd>
<dt><strong><code>data_directory</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory where the binary file is located</dd>
<dt><strong><code>dimension_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The shape of the spectral data</dd>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>int</code></dt>
<dd>How many dimensions there are</dd>
<dt><strong><code>do_hull</code></strong> :&ensp;<code>bool</code></dt>
<dd>Use a convex hull if spectral extraction is performed</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>the spectral features for the dataset if they are calculated</dd>
<dt><strong><code>file_base_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The file name without the path</dd>
<dt><strong><code>filename_bits</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The filename split into the base name and extension</dd>
<dt><strong><code>inspection_indices</code></strong> :&ensp;<code>list</code></dt>
<dd>The indices that correspond to the wavelengths of the inspection_range</dd>
<dt><strong><code>inspection_range</code></strong> :&ensp;<code>list</code></dt>
<dd>The desired range to use for spectral feature extraction e.g. [2000, 2500]</dd>
<dt><strong><code>instrument_name</code></strong> :&ensp;<code>str</code></dt>
<dd>'TSG'</dd>
<dt><strong><code>is_this_TIR</code></strong> :&ensp;<code>bool</code></dt>
<dd>If _tir is found in the filename this flag is set to True otherwise False</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>list</code></dt>
<dd>False where the data is no good and True where it is good</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>The TSG files ENVI hdr information</dd>
<dt><strong><code>ordinates</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The ordinates associated with the spectral data</dd>
<dt><strong><code>return_hull</code></strong> :&ensp;<code>bool</code></dt>
<dd>to return the actual hull or not. Default is False</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The TSG spectral data (samples x bands)</dd>
<dt><strong><code>spectral_mix</code></strong> :&ensp;<code>unknown</code></dt>
<dd>Hmm probably when I was mucking around with unmixing. TODO maybe delete this</dd>
<dt><strong><code>tsg_text_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The pathname of the input *.tsg file</dd>
</dl>
<p>Create an instance of a Tsg class to either retrieve spectra and/or metadata associated with the TSG dataset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instrument_files</code></strong> :&ensp;<code>list</code></dt>
<dd>A list [path to TSG binary file, path to TSG .tsg file]</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>from spex.io.instrument import Tsg</p>
<p>input_files = ["tsg_test.bip", "tsg_test.tsg"]</p>
<p>Tsg_dataset = Tsg(input_files)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tsg(Instrument):
    &#34;&#34;&#34;
    Return an instance of the Instrument class for a TSG dataset

    Attributes:
        band_header_data (Dataframe): The contents of the additional data contained in a TSG file e.g. depths, scalars

        band_header_data_names (list): The column names of the data in the band_header_data

        bip_file (str): The path name of the TSG binary file

        data_directory (str): The directory where the binary file is located

        dimension_shape (tuple): The shape of the spectral data

        dimensions (int): How many dimensions there are

        do_hull (bool): Use a convex hull if spectral extraction is performed

        features (numpy array): the spectral features for the dataset if they are calculated

        file_base_name (str): The file name without the path

        filename_bits (tuple): The filename split into the base name and extension

        inspection_indices (list): The indices that correspond to the wavelengths of the inspection_range

        inspection_range (list): The desired range to use for spectral feature extraction e.g. [2000, 2500]

        instrument_name (str): &#39;TSG&#39;

        is_this_TIR (bool): If _tir is found in the filename this flag is set to True otherwise False

        mask (list): False where the data is no good and True where it is good

        metadata (dict): The TSG files ENVI hdr information

        ordinates (ndarray): The ordinates associated with the spectral data

        return_hull (bool): to return the actual hull or not. Default is False

        spectra (ndarray): The TSG spectral data (samples x bands)

        spectral_mix (unknown): Hmm probably when I was mucking around with unmixing. TODO maybe delete this

        tsg_text_file (str): The pathname of the input *.tsg file

    &#34;&#34;&#34;

    def __init__(self, instrument_files):
        &#34;&#34;&#34;
        Create an instance of a Tsg class to either retrieve spectra and/or metadata associated with the TSG dataset

        Args:
            instrument_files (list): A list [path to TSG binary file, path to TSG .tsg file]

        Examples:
            from spex.io.instrument import Tsg

            input_files = [&#34;tsg_test.bip&#34;, &#34;tsg_test.tsg&#34;]

            Tsg_dataset = Tsg(input_files)

        &#34;&#34;&#34;
        self.instrument_name = &#39;TSG&#39;
        self.bip_file = instrument_files[0]
        self.tsg_text_file = instrument_files[1]
        #self.existing_header_file = None
        self.data_directory = os.path.dirname(self.bip_file)
        self.file_base_name = os.path.basename(self.bip_file)
        self.filename_bits = os.path.splitext(self.file_base_name)
        self.is_this_TIR = False
        #self.flip_data_along_yaxis = False
        self.ordinates = None
        #self.whats_not_masked = None
        self.return_hull = False
        #self.load_all = True
        self.band_header_data_names = None
        self.band_header_data = None
        self.mask = None
        self.dimensions = None
        self.features = None
        self.spectral_mix = None

        if &#39;.tsg&#39; in self.tsg_text_file:
            # read in the tsg file and create a header file
            header_file, header = self.read_tsg_file()
            tsg_data = self._open_with_generated_header(header, image=self.bip_file)

            self.ordinates = np.asarray(tsg_data.bands.centers)
            if self.band_header_data.filter(like=&#39;Final Mask&#39;).shape[1] &gt; 0:
                self.mask = list(self.band_header_data.filter(like=&#39;Final Mask&#39;).values[:, 0] &gt; 0)
            else:
                self.mask = list(np.ones(tsg_data.params.nrows, dtype=bool))

            self.spectra = tsg_data.spectra  # self.return_all_spectra()  # self.tsg_data.spectra
            self.dimensions = self.spectra.ndim
            self.dimension_shape = self.spectra.shape
            self.metadata = tsg_data.metadata
        else:
            print(&#39;Nope!, I need a bip file and a tsg file&#39;)

        self.do_hull = True
        self.is_this_TIR = False
        # see if it is a TIR file
        if &#39;_tir&#39; in self.bip_file:
            self.is_this_TIR = True
            self.do_hull = False

        self.inspection_range = None
        self.inspection_indices = None

    def get_ordinates(self):
        &#34;&#34;&#34;
        returns the ordinates associated with the TSG spectral data

        &#34;&#34;&#34;
        return self.ordinates

    def datagenerator(self):
        &#34;&#34;&#34;
        an iterator to return a single spectrum at a time from the TSG dataset

        Yields:
            A spectrum from the dataset

        &#34;&#34;&#34;
        for spectrum in self.spectra: #tsg_data.spectra:
            yield spectrum

    def read_tsg_file(self):
        # open the tsg file and get the text information
        &#34;&#34;&#34;
        A reader for the *.tsg file

        Returns:
            tsg filename, a dict of the metadata items needed to construct an ENVI header file

        &#34;&#34;&#34;

        with open(self.tsg_text_file, mode=&#39;r&#39;) as f:
            tsg_file_data = f.readlines()

            # get the indices and names of all the items within [] tags
            where_are_the_headers = [(index, x.split(&#34;\n&#34;)[0]) for index, x in enumerate(tsg_file_data) if &#39;[&#39; in x]

            # a dictionary for storing additional parameters needed in the *.hdr file
            d = {&#39;description&#39;: &#39;Extracted info from the .tsg file to make this ENVI header file.&#39;,
                 &#39;lines&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastsample =&#39; in s][0],
                 &#39;samples&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastband =&#39; in s][0], &#39;bands&#39;: &#39;1&#39;,
                 &#39;header offset&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;dataheader =&#39; in s][0], &#39;data type&#39;: &#39;4&#39;,
                 &#39;interleave&#39;: &#39;bsq&#39;, &#39;byte order&#39;: &#39;0&#39;}
            # In an ENVI spectral library the lines are the number of samples and the samples are the number of bands

            # get the sample names. This is often massive
            index = [index for index, s in enumerate(tsg_file_data) if &#39;[sample headers]&#39; in s][0] + 1
            spectra_names = []
            for i in range(int(d.get(&#39;lines&#39;))):
                spectra_names.append(tsg_file_data[index + i].split(&#39;:&#39;)[1])
            d[&#39;spectra names&#39;] = spectra_names

            index = [index for index, s in enumerate(tsg_file_data) if &#39;[wavelength specs]&#39; in s][0] + 1
            wave_specs = tsg_file_data[index].split()[0:2]
            delta_waves = round((float(wave_specs[1]) - float(wave_specs[0])) / float(d[&#39;samples&#39;]))
            wavelengths = []
            for i in range(int(d[&#39;samples&#39;])):
                wavelengths.append(float(wave_specs[0]) + i * delta_waves)
            d[&#39;wavelength&#39;] = wavelengths

            # lets get all of the other information stuffed into the binary file for each sample
            band_hdr = [(index, x[0]) for index, x in enumerate(where_are_the_headers) if &#39;[band headers]&#39; in x[1]][0]
            band_hdr_start = band_hdr[1] + 1
            band_hdr_stop = where_are_the_headers[band_hdr[0] + 1][0] - 1
            band_header_indices = [np.long(x.split(&#34;:&#34;)[0]) for x in tsg_file_data[band_hdr_start:band_hdr_stop]]
            band_header_fields = [x.split(&#34;:&#34;)[1].split(&#34;;&#34;)[0].split(&#34;\n&#34;)[0] for x in
                                  tsg_file_data[band_hdr_start:band_hdr_stop]]

            # open a memmap that is past the spectral data.
            # We are going to grab all the other data associated with each spectrum
            offset = int(d[&#39;lines&#39;]) * int(d[&#39;samples&#39;]) * np.dtype(&#39;float32&#39;).itemsize
            file_memmap = np.memmap(self.bip_file, dtype=&#39;float32&#39;, mode=&#39;r&#39;, offset=offset,
                                    shape=(int(d[&#39;lines&#39;]), int(d[&#39;samples&#39;])))

            # lets create a pandas dataset of the header data and store it
            header_data = np.asarray(file_memmap[:, band_header_indices])
            tsg_df = pd.DataFrame(header_data, columns=band_header_fields)
            self.band_header_data_names = band_header_fields
            self.band_header_data = tsg_df

            base_filename = os.path.splitext(self.bip_file)[0]
            out_filename = base_filename + &#39;.hdr&#39;
            if os.access(os.path.dirname(out_filename), os.W_OK):
                envi.write_envi_header(out_filename, d, is_library=True)
                d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
            else:
                d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
                out_filename = None

        return out_filename, d

    def make_header_dict(self, tsg_file_data):
        # open the tsg file and get the text information
        &#34;&#34;&#34;
        Gathers up the required metadata needed to create an internal representation of an ENVI header file that in turn
        allows us to read the TSG *.bip file via spectral pythons routines

        Args:
            tsg_file_data (list): A list containing the various metadata contained in a *.tsg file

        Returns:
            dict: A dict of the various metadata items in a format compatible with an ENVI header

        &#34;&#34;&#34;

        # a dictionary for storing additional parameters needed in the *.hdr file
        d = {&#39;description&#39;: &#39;extracted header file from TSG&#39;,
             &#39;lines&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastsample =&#39; in s][0],
             &#39;samples&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastband =&#39; in s][0], &#39;bands&#39;: &#39;1&#39;,
             &#39;header offset&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;dataheader =&#39; in s][0], &#39;data type&#39;: &#39;4&#39;,
             &#39;interleave&#39;: &#39;bsq&#39;, &#39;byte order&#39;: &#39;0&#39;}
        # extract the metadata we need for the *.hdr file
        # in a envi spectral library the lines are the number of samples and the samples are the number of bands

        # get the sample names. This is often massive
        index = [index for index, s in enumerate(tsg_file_data) if &#39;sample headers&#39; in s][0] + 1
        spectra_names = []
        for i in range(int(d.get(&#39;lines&#39;))):
            spectra_names.append(tsg_file_data[index + i].split(&#39;:&#39;)[1])
        d[&#39;spectra names&#39;] = spectra_names

        index = [index for index, s in enumerate(tsg_file_data) if &#39;[wavelength specs]&#39; in s][0] + 1
        wave_specs = tsg_file_data[index].split()[0:2]
        delta_waves = round((float(wave_specs[1]) - float(wave_specs[0])) / float(d[&#39;samples&#39;]))
        wvls = []
        for i in range(int(d[&#39;samples&#39;])):
            wvls.append(float(wave_specs[0]) + i * delta_waves)
        d[&#39;wavelength&#39;] = wvls

        # open a memmap
        offset = int(d[&#39;lines&#39;]) * int(d[&#39;samples&#39;]) * np.dtype(&#39;float32&#39;).itemsize
        file_memmap = np.memmap(self.bip_file, dtype=&#39;float32&#39;, mode=&#39;r&#39;, offset=offset,
                                shape=(int(d[&#39;lines&#39;]), int(d[&#39;samples&#39;])))

        depth_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Depth (m);&#39; in s]
        if depth_index:
            d[&#39;depths&#39;] = np.asarray(file_memmap[:, depth_index[0]])
        else:
            d[&#39;depths&#39;] = range(int(d[&#39;lines&#39;]))

        final_mask_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Final Mask;&#39; in s]
        if final_mask_index:
            d[&#39;mask&#39;] = np.asarray(file_memmap[:, final_mask_index[0]])
        else:
            kahuna_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Kahuna;&#39; in s]
            if kahuna_index:
                d[&#39;mask&#39;] = np.asarray(file_memmap[:, kahuna_index[0]])
            else:
                d[&#39;mask&#39;] = np.full(int(d[&#39;lines&#39;]), 1)

        prof_min_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:prof_min;&#39; in s]
        if prof_min_index:
            d[&#39;prof_min&#39;] = np.asarray(file_memmap[:, prof_min_index[0]])

        d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
        return d

    @staticmethod
    def _open_with_generated_header(header_dictionary, image=None):
        &#34;&#34;&#34;
        Opens an image or spectral library with an associated ENVI HDR header file

        Args:
            header_dictionary (dict): a dict of the TSG data file metadata
            image (str): Optional name of the associated image data file.

        Returns:
            (object): class:`spectral.SpyFile` or :class:`spectral.io.envi.SpectralLibrary`

        Raises:

            TypeError, EnviDataFileNotFoundError

        If the specified file is not found in the current directory, all
        directories listed in the SPECTRAL_DATA environment variable will be
        searched until the file is found.  Based on the name of the header file,
        this function will search for the image file in the same directory as the
        header, looking for a file with the same name as the header but different
        extension. Extensions recognized are .img, .dat, .sli, and no extension.
        Capitalized versions of the file extensions are also searched.

        &#34;&#34;&#34;
        envi.check_compatibility(header_dictionary)
        envi_information = envi.gen_params(header_dictionary)
        envi_information.filename = image

        if header_dictionary.get(&#39;file type&#39;) == &#39;ENVI Spectral Library&#39;:
            # File is a spectral library
            data = np.fromfile(envi_information.filename, envi_information.dtype,
                               envi_information.ncols * envi_information.nrows)
            data.shape = (envi_information.nrows, envi_information.ncols)
            return envi.SpectralLibrary(data, header_dictionary, envi_information)

        #  Create the appropriate object type for the interleave format.
        inter = header_dictionary[&#34;interleave&#34;]
        if inter == &#39;bil&#39; or inter == &#39;BIL&#39;:
            from spectral.io.bilfile import BilFile
            img = BilFile(envi_information, header_dictionary)
        elif inter == &#39;bip&#39; or inter == &#39;BIP&#39;:
            from spectral.io.bipfile import BipFile
            img = BipFile(envi_information, header_dictionary)
        else:
            from spectral.io.bsqfile import BsqFile
            img = BsqFile(envi_information, header_dictionary)

        img.scale_factor = float(header_dictionary.get(&#39;reflectance scale factor&#39;, 1.0))

        # Add band info

        if &#39;wavelength&#39; in header_dictionary:
            try:
                img.bands.centers = [float(b) for b in header_dictionary[&#39;wavelength&#39;]]
            except:
                pass
        if &#39;fwhm&#39; in header_dictionary:
            try:
                img.bands.bandwidths = [float(f) for f in header_dictionary[&#39;fwhm&#39;]]
            except:
                pass
        img.bands.band_unit = header_dictionary.get(&#39;wavelength units&#39;, None)

        if &#39;bbl&#39; in header_dictionary:
            try:
                header_dictionary[&#39;bbl&#39;] = [int(b) for b in header_dictionary[&#39;bbl&#39;]]
            except:
                print(&#39;Unable to parse bad band list (bbl) in header as integers.&#39;)
        return img

    def return_band_header_data(self):
        &#34;&#34;&#34;
        returns all of the band header data if it exists.

        In a TSG file this would be things like the depth, scalars, etc

        &#34;&#34;&#34;
        return self.band_header_data

    def return_all_spectra(self):
        &#34;&#34;&#34;
        return all of the spectra as a numpy array

        &#34;&#34;&#34;
        spectrum = self.spectra
        return spectrum

    def return_single_spectrum(self, sample_number):
        &#34;&#34;&#34;
        returns the spectrum at sample location sample_number

        Args:
            sample_number (int): Index location in the spectral array that you want the sample from

        Returns:
            A numpy array with the spectrum found at sample_number

        &#34;&#34;&#34;
        spectrum = self.spectra[sample_number, :]
        return spectrum</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="spex.io.instruments.Instrument" href="#spex.io.instruments.Instrument">Instrument</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spex.io.instruments.Tsg.datagenerator"><code class="name flex">
<span>def <span class="ident">datagenerator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>an iterator to return a single spectrum at a time from the TSG dataset</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>A spectrum from the dataset</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datagenerator(self):
    &#34;&#34;&#34;
    an iterator to return a single spectrum at a time from the TSG dataset

    Yields:
        A spectrum from the dataset

    &#34;&#34;&#34;
    for spectrum in self.spectra: #tsg_data.spectra:
        yield spectrum</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Tsg.get_ordinates"><code class="name flex">
<span>def <span class="ident">get_ordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the ordinates associated with the TSG spectral data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ordinates(self):
    &#34;&#34;&#34;
    returns the ordinates associated with the TSG spectral data

    &#34;&#34;&#34;
    return self.ordinates</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Tsg.make_header_dict"><code class="name flex">
<span>def <span class="ident">make_header_dict</span></span>(<span>self, tsg_file_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Gathers up the required metadata needed to create an internal representation of an ENVI header file that in turn
allows us to read the TSG *.bip file via spectral pythons routines</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tsg_file_data</code></strong> :&ensp;<code>list</code></dt>
<dd>A list containing the various metadata contained in a *.tsg file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dict of the various metadata items in a format compatible with an ENVI header</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_header_dict(self, tsg_file_data):
    # open the tsg file and get the text information
    &#34;&#34;&#34;
    Gathers up the required metadata needed to create an internal representation of an ENVI header file that in turn
    allows us to read the TSG *.bip file via spectral pythons routines

    Args:
        tsg_file_data (list): A list containing the various metadata contained in a *.tsg file

    Returns:
        dict: A dict of the various metadata items in a format compatible with an ENVI header

    &#34;&#34;&#34;

    # a dictionary for storing additional parameters needed in the *.hdr file
    d = {&#39;description&#39;: &#39;extracted header file from TSG&#39;,
         &#39;lines&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastsample =&#39; in s][0],
         &#39;samples&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastband =&#39; in s][0], &#39;bands&#39;: &#39;1&#39;,
         &#39;header offset&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;dataheader =&#39; in s][0], &#39;data type&#39;: &#39;4&#39;,
         &#39;interleave&#39;: &#39;bsq&#39;, &#39;byte order&#39;: &#39;0&#39;}
    # extract the metadata we need for the *.hdr file
    # in a envi spectral library the lines are the number of samples and the samples are the number of bands

    # get the sample names. This is often massive
    index = [index for index, s in enumerate(tsg_file_data) if &#39;sample headers&#39; in s][0] + 1
    spectra_names = []
    for i in range(int(d.get(&#39;lines&#39;))):
        spectra_names.append(tsg_file_data[index + i].split(&#39;:&#39;)[1])
    d[&#39;spectra names&#39;] = spectra_names

    index = [index for index, s in enumerate(tsg_file_data) if &#39;[wavelength specs]&#39; in s][0] + 1
    wave_specs = tsg_file_data[index].split()[0:2]
    delta_waves = round((float(wave_specs[1]) - float(wave_specs[0])) / float(d[&#39;samples&#39;]))
    wvls = []
    for i in range(int(d[&#39;samples&#39;])):
        wvls.append(float(wave_specs[0]) + i * delta_waves)
    d[&#39;wavelength&#39;] = wvls

    # open a memmap
    offset = int(d[&#39;lines&#39;]) * int(d[&#39;samples&#39;]) * np.dtype(&#39;float32&#39;).itemsize
    file_memmap = np.memmap(self.bip_file, dtype=&#39;float32&#39;, mode=&#39;r&#39;, offset=offset,
                            shape=(int(d[&#39;lines&#39;]), int(d[&#39;samples&#39;])))

    depth_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Depth (m);&#39; in s]
    if depth_index:
        d[&#39;depths&#39;] = np.asarray(file_memmap[:, depth_index[0]])
    else:
        d[&#39;depths&#39;] = range(int(d[&#39;lines&#39;]))

    final_mask_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Final Mask;&#39; in s]
    if final_mask_index:
        d[&#39;mask&#39;] = np.asarray(file_memmap[:, final_mask_index[0]])
    else:
        kahuna_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:Kahuna;&#39; in s]
        if kahuna_index:
            d[&#39;mask&#39;] = np.asarray(file_memmap[:, kahuna_index[0]])
        else:
            d[&#39;mask&#39;] = np.full(int(d[&#39;lines&#39;]), 1)

    prof_min_index = [int(s.split(&#34;:&#34;)[0]) for s in tsg_file_data if &#39;:prof_min;&#39; in s]
    if prof_min_index:
        d[&#39;prof_min&#39;] = np.asarray(file_memmap[:, prof_min_index[0]])

    d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
    return d</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Tsg.read_tsg_file"><code class="name flex">
<span>def <span class="ident">read_tsg_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A reader for the *.tsg file</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tsg filename, a dict</code> of <code>the metadata items needed to construct an ENVI header file</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_tsg_file(self):
    # open the tsg file and get the text information
    &#34;&#34;&#34;
    A reader for the *.tsg file

    Returns:
        tsg filename, a dict of the metadata items needed to construct an ENVI header file

    &#34;&#34;&#34;

    with open(self.tsg_text_file, mode=&#39;r&#39;) as f:
        tsg_file_data = f.readlines()

        # get the indices and names of all the items within [] tags
        where_are_the_headers = [(index, x.split(&#34;\n&#34;)[0]) for index, x in enumerate(tsg_file_data) if &#39;[&#39; in x]

        # a dictionary for storing additional parameters needed in the *.hdr file
        d = {&#39;description&#39;: &#39;Extracted info from the .tsg file to make this ENVI header file.&#39;,
             &#39;lines&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastsample =&#39; in s][0],
             &#39;samples&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;lastband =&#39; in s][0], &#39;bands&#39;: &#39;1&#39;,
             &#39;header offset&#39;: [s.split(&#34;=&#34;)[1] for s in tsg_file_data if &#39;dataheader =&#39; in s][0], &#39;data type&#39;: &#39;4&#39;,
             &#39;interleave&#39;: &#39;bsq&#39;, &#39;byte order&#39;: &#39;0&#39;}
        # In an ENVI spectral library the lines are the number of samples and the samples are the number of bands

        # get the sample names. This is often massive
        index = [index for index, s in enumerate(tsg_file_data) if &#39;[sample headers]&#39; in s][0] + 1
        spectra_names = []
        for i in range(int(d.get(&#39;lines&#39;))):
            spectra_names.append(tsg_file_data[index + i].split(&#39;:&#39;)[1])
        d[&#39;spectra names&#39;] = spectra_names

        index = [index for index, s in enumerate(tsg_file_data) if &#39;[wavelength specs]&#39; in s][0] + 1
        wave_specs = tsg_file_data[index].split()[0:2]
        delta_waves = round((float(wave_specs[1]) - float(wave_specs[0])) / float(d[&#39;samples&#39;]))
        wavelengths = []
        for i in range(int(d[&#39;samples&#39;])):
            wavelengths.append(float(wave_specs[0]) + i * delta_waves)
        d[&#39;wavelength&#39;] = wavelengths

        # lets get all of the other information stuffed into the binary file for each sample
        band_hdr = [(index, x[0]) for index, x in enumerate(where_are_the_headers) if &#39;[band headers]&#39; in x[1]][0]
        band_hdr_start = band_hdr[1] + 1
        band_hdr_stop = where_are_the_headers[band_hdr[0] + 1][0] - 1
        band_header_indices = [np.long(x.split(&#34;:&#34;)[0]) for x in tsg_file_data[band_hdr_start:band_hdr_stop]]
        band_header_fields = [x.split(&#34;:&#34;)[1].split(&#34;;&#34;)[0].split(&#34;\n&#34;)[0] for x in
                              tsg_file_data[band_hdr_start:band_hdr_stop]]

        # open a memmap that is past the spectral data.
        # We are going to grab all the other data associated with each spectrum
        offset = int(d[&#39;lines&#39;]) * int(d[&#39;samples&#39;]) * np.dtype(&#39;float32&#39;).itemsize
        file_memmap = np.memmap(self.bip_file, dtype=&#39;float32&#39;, mode=&#39;r&#39;, offset=offset,
                                shape=(int(d[&#39;lines&#39;]), int(d[&#39;samples&#39;])))

        # lets create a pandas dataset of the header data and store it
        header_data = np.asarray(file_memmap[:, band_header_indices])
        tsg_df = pd.DataFrame(header_data, columns=band_header_fields)
        self.band_header_data_names = band_header_fields
        self.band_header_data = tsg_df

        base_filename = os.path.splitext(self.bip_file)[0]
        out_filename = base_filename + &#39;.hdr&#39;
        if os.access(os.path.dirname(out_filename), os.W_OK):
            envi.write_envi_header(out_filename, d, is_library=True)
            d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
        else:
            d[&#39;file type&#39;] = &#39;ENVI Spectral Library&#39;
            out_filename = None

    return out_filename, d</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Tsg.return_all_spectra"><code class="name flex">
<span>def <span class="ident">return_all_spectra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all of the spectra as a numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_all_spectra(self):
    &#34;&#34;&#34;
    return all of the spectra as a numpy array

    &#34;&#34;&#34;
    spectrum = self.spectra
    return spectrum</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Tsg.return_band_header_data"><code class="name flex">
<span>def <span class="ident">return_band_header_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns all of the band header data if it exists.</p>
<p>In a TSG file this would be things like the depth, scalars, etc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_band_header_data(self):
    &#34;&#34;&#34;
    returns all of the band header data if it exists.

    In a TSG file this would be things like the depth, scalars, etc

    &#34;&#34;&#34;
    return self.band_header_data</code></pre>
</details>
</dd>
<dt id="spex.io.instruments.Tsg.return_single_spectrum"><code class="name flex">
<span>def <span class="ident">return_single_spectrum</span></span>(<span>self, sample_number)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the spectrum at sample location sample_number</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Index location in the spectral array that you want the sample from</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A numpy array with the spectrum found at sample_number</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_single_spectrum(self, sample_number):
    &#34;&#34;&#34;
    returns the spectrum at sample location sample_number

    Args:
        sample_number (int): Index location in the spectral array that you want the sample from

    Returns:
        A numpy array with the spectrum found at sample_number

    &#34;&#34;&#34;
    spectrum = self.spectra[sample_number, :]
    return spectrum</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spex.io" href="index.html">spex.io</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spex.io.instruments.CsvSpectra" href="#spex.io.instruments.CsvSpectra">CsvSpectra</a></code></h4>
<ul class="">
<li><code><a title="spex.io.instruments.CsvSpectra.datagenerator" href="#spex.io.instruments.CsvSpectra.datagenerator">datagenerator</a></code></li>
<li><code><a title="spex.io.instruments.CsvSpectra.get_ordinates" href="#spex.io.instruments.CsvSpectra.get_ordinates">get_ordinates</a></code></li>
<li><code><a title="spex.io.instruments.CsvSpectra.return_all_spectra" href="#spex.io.instruments.CsvSpectra.return_all_spectra">return_all_spectra</a></code></li>
<li><code><a title="spex.io.instruments.CsvSpectra.return_single_spectrum" href="#spex.io.instruments.CsvSpectra.return_single_spectrum">return_single_spectrum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spex.io.instruments.ImageData" href="#spex.io.instruments.ImageData">ImageData</a></code></h4>
<ul class="">
<li><code><a title="spex.io.instruments.ImageData.datagenerator" href="#spex.io.instruments.ImageData.datagenerator">datagenerator</a></code></li>
<li><code><a title="spex.io.instruments.ImageData.get_ordinates" href="#spex.io.instruments.ImageData.get_ordinates">get_ordinates</a></code></li>
<li><code><a title="spex.io.instruments.ImageData.return_all_spectra" href="#spex.io.instruments.ImageData.return_all_spectra">return_all_spectra</a></code></li>
<li><code><a title="spex.io.instruments.ImageData.return_single_spectrum" href="#spex.io.instruments.ImageData.return_single_spectrum">return_single_spectrum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spex.io.instruments.Instrument" href="#spex.io.instruments.Instrument">Instrument</a></code></h4>
<ul class="">
<li><code><a title="spex.io.instruments.Instrument.datagenerator" href="#spex.io.instruments.Instrument.datagenerator">datagenerator</a></code></li>
<li><code><a title="spex.io.instruments.Instrument.get_ordinates" href="#spex.io.instruments.Instrument.get_ordinates">get_ordinates</a></code></li>
<li><code><a title="spex.io.instruments.Instrument.return_all_spectra" href="#spex.io.instruments.Instrument.return_all_spectra">return_all_spectra</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spex.io.instruments.NumpySpectra" href="#spex.io.instruments.NumpySpectra">NumpySpectra</a></code></h4>
<ul class="">
<li><code><a title="spex.io.instruments.NumpySpectra.datagenerator" href="#spex.io.instruments.NumpySpectra.datagenerator">datagenerator</a></code></li>
<li><code><a title="spex.io.instruments.NumpySpectra.get_ordinates" href="#spex.io.instruments.NumpySpectra.get_ordinates">get_ordinates</a></code></li>
<li><code><a title="spex.io.instruments.NumpySpectra.return_all_spectra" href="#spex.io.instruments.NumpySpectra.return_all_spectra">return_all_spectra</a></code></li>
<li><code><a title="spex.io.instruments.NumpySpectra.return_single_spectrum" href="#spex.io.instruments.NumpySpectra.return_single_spectrum">return_single_spectrum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spex.io.instruments.Tsg" href="#spex.io.instruments.Tsg">Tsg</a></code></h4>
<ul class="">
<li><code><a title="spex.io.instruments.Tsg.datagenerator" href="#spex.io.instruments.Tsg.datagenerator">datagenerator</a></code></li>
<li><code><a title="spex.io.instruments.Tsg.get_ordinates" href="#spex.io.instruments.Tsg.get_ordinates">get_ordinates</a></code></li>
<li><code><a title="spex.io.instruments.Tsg.make_header_dict" href="#spex.io.instruments.Tsg.make_header_dict">make_header_dict</a></code></li>
<li><code><a title="spex.io.instruments.Tsg.read_tsg_file" href="#spex.io.instruments.Tsg.read_tsg_file">read_tsg_file</a></code></li>
<li><code><a title="spex.io.instruments.Tsg.return_all_spectra" href="#spex.io.instruments.Tsg.return_all_spectra">return_all_spectra</a></code></li>
<li><code><a title="spex.io.instruments.Tsg.return_band_header_data" href="#spex.io.instruments.Tsg.return_band_header_data">return_band_header_data</a></code></li>
<li><code><a title="spex.io.instruments.Tsg.return_single_spectrum" href="#spex.io.instruments.Tsg.return_single_spectrum">return_single_spectrum</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>